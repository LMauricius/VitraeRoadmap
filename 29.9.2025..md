# Vitrae Development roadmap

## Game-ready 3D engine {-}
The core idea of VitraeEngine is for it to be ready both for graphics research
and for production software.
It's necessary to implement a couple key features that will cover 
all traditional use-cases for a pure graphics engine.

### Animation system
The ideal animation system is modular and tied to assets that intuitively support animation.
It has to support skeletal animations, mesh-morphing animations
and dynamic animations such as inverse kinematics.

1. High-level design of animation system
2. Programming interface for the system
3. Implementation of a modular system
4. Implementation of common methods as examples

### Smart scene graph
The current scene system is a placeholder for something bigger.
There is a way to design a scene graph that does't require much thought about the structure
but is fast and flexible:
- The scene is just a list of all objects (called props) {h}
- The engine automatically builds a suitable structure - key for performance  {h}

#### SQueLe library 
SQueLe is a WIP programming library invented for this purpose: advanced querying facilities to build optimal data from simple directives.
1. Stabilize the core API 
2. Build base classes and concepts
3. Implement a couple queries and views
4. ???
5. Profit

#### Scene database
The scene itself is a trivially simple hierarchical database - it's just a list of props. Of course, some props are used as a subscene to increase reusability. Each subscene could have multiple levels of detail (LoDs) and usage profiles.
1. Design a prop and LoD structure
2. Build a dynamic prop list extraction facility using SQueLe
3. Implement a couple commonly used queries for scene rendering

## Inventive graphical programming features
VitraeEngine was created with graphical advancements as a first-class usage goal.

### Tensor buffers {y}    
By leveraging the flexibility of the hardware rasterizer and texture sampling,
we can enable more memory manipulation and compression features for some buffers.
These texture element based buffers will be called `TensorBuffers`
due to them being structures of scalars and vectors.
1. Add image control and sampling to the shader system {y} 
2. Implement TensorBuffer class
3. Auto generation of TensorBuffer manipulation code in shaders
4. Direct output to TensorBuffers using the rasterizer

### Edge-adjusted antialiased shadows
There is a WIP shadow system that could solve a number of problems with modern shadow mapping.
1. Port EAA shadows to the newer Vitrae version
2. Get rid of artifacts
3. Implement dynamic penumbra sizing
4. Profit

### Global illumination
With the newer Vitrae features,
the GI that was worked on as part of my master's thesis can be made leagues more performant.
Tensor buffers are key.
1. Refactor the GI solution to use TensorBuffers
2. Fix visibility detection
3. Accelerate GI propagation by implementing the parent-child lighting normalization